import { type BuildHookOptions, MULTI_VALUE } from '@terrazzo/parser';
import { getTokenMatcher } from '@terrazzo/token-tools';
import { FORMAT_ID, type SassPluginOptions } from './lib.js';
import { CssVarReferenceSassToken, RootSassToken, type SassMapKey, type SassMapValue, type SassToken } from './node.js';

export interface BuildParams {
  getTransforms: BuildHookOptions['getTransforms'];
  options?: SassPluginOptions;
}

const FONT_SHORTHAND_PROPERTIES = [
  'font-family',
  'font-size',
  'font-style',
  'font-variant',
  'font-weight',
  'line-height',
];

const SASS_HEADER = `////
/// Autogenerated by â›‹ Terrazzo. DO NOT EDIT!
////
`;

const SASS_LIB = `@function token($tokenName) {
  @if not map.has-key($__token-values, $tokenName) {
    @error 'No token named "#{$tokenName}"';
  }

  $token: map.get($__token-values, $tokenName);

  @if $token == "__tz-error-typography" {
    @error "This is a typography mixin. Use \`@include typography("#{tokenId}")\` instead.";
  }

  @return $token;
}

@mixin typography($tokenName) {
  @if not map.has-key($__token-typography-mixins, $tokenName) {
    @error 'No typography mixin named "#{$tokenName}"';
  }

  $mixin: map.get($__token-typography-mixins, $tokenName);

  @each $_property, $_value in $mixin {
    #{$_property}: #{$_value};
  }
}
`;

export default async function build({ getTransforms, options }: BuildParams): Promise<string> {
  const root = new RootSassToken();
  root.appendString(SASS_HEADER);
  root.appendUse('sass:list');
  root.appendUse('sass:map');
  root.appendBlankLine();

  const tokenValuesMap = root.createMap();

  const exclude = options?.exclude ? getTokenMatcher(options?.exclude) : undefined;

  for (const token of getTransforms({ format: FORMAT_ID, id: '*', mode: '.' })) {
    if (exclude?.(token.token.id)) {
      continue;
    }
    const tokenId = token.token.id;
    const tokenName = token.localID ?? tokenId;
    if (token.token.$type === 'typography' && token.type === MULTI_VALUE) {
      const tokenValue = token.value;
      const typographySassVars = new Map<SassMapKey, SassToken>(
        Object.keys(tokenValue).map((key) => [
          `${tokenId}.${key}`,
          new CssVarReferenceSassToken(`${tokenName}-${key}`),
        ]),
      );
      if ('font-size' in tokenValue && 'font-family' in tokenValue) {
        typographySassVars.set(tokenId, new CssVarReferenceSassToken(tokenName));
      }
      tokenValuesMap.extend(typographySassVars);
    } else {
      tokenValuesMap.set(tokenId, new CssVarReferenceSassToken(tokenName));
    }
  }
  root.appendVariableDefinition('$__token-values', tokenValuesMap);
  root.appendBlankLine();
  const tokenTypographyMixinsMap = root.createMap();

  for (const token of getTransforms({ format: 'css', id: '*', mode: '.', $type: 'typography' })) {
    if (typeof token.value === 'string') {
      continue;
    }
    const tokenId = token.token.id;
    const tokenName = token.localID ?? tokenId;
    const tokenValue = token.value;
    const values = { ...token.value };
    const fontMap = tokenTypographyMixinsMap.createMap();
    if ('font-size' in tokenValue && 'font-family' in tokenValue) {
      fontMap.set('font', new CssVarReferenceSassToken(`${tokenName}`));
      for (const property of FONT_SHORTHAND_PROPERTIES) {
        delete values[property];
      }
    }
    fontMap.extend(
      Object.keys(values).map(
        (propertyName) =>
          [propertyName, new CssVarReferenceSassToken(`${tokenName}-${propertyName}`)] as [SassMapKey, SassMapValue],
      ),
    );
    tokenTypographyMixinsMap.set(tokenId, fontMap);
  }

  root.appendVariableDefinition('$__token-typography-mixins', tokenTypographyMixinsMap);
  root.appendBlankLine();
  root.appendString(SASS_LIB);
  return root.toString();
}
