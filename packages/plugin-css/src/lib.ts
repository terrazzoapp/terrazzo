import { createRequire } from 'node:module';
import type { TokenNormalized, TokenTransformed } from '@terrazzo/parser';

export type UtilityCSSGroup = 'bg' | 'border' | 'font' | 'layout' | 'shadow' | 'text';

export type UtilityCSSPrefix = 'bg' | 'border' | 'font' | 'gap' | 'm' | 'p' | 'shadow' | 'text';

export const FORMAT_ID = 'css';

export const FILE_PREFIX = `/* -------------------------------------------
 *  Autogenerated by ⛋ Terrazzo. DO NOT EDIT!
 * ------------------------------------------- */`;

const require = createRequire(import.meta.url);
const { Biome } = require('@biomejs/js-api/nodejs');

const biome = new Biome();
const { projectKey } = biome.openProject();
biome.applyConfiguration(projectKey, {
  css: {
    formatter: {
      indentWidth: 2,
      indentStyle: 'space',
      lineWidth: 320,
    },
  },
});

export const formatCSS = (code: string) => {
  return biome.formatContent(projectKey, code, { filePath: 'index.css' }).content;
};

const joinSelectors = (selectors: string[]) => {
  return selectors.join(',\n');
};

const isVendorPrefixed = (property: string) => {
  return property.startsWith('-webkit-');
};

export interface CSSPluginOptions {
  /**
   * Where to output CSS
   * @default "index.css"
   */
  filename?: string;
  /** Glob patterns to exclude tokens from output */
  exclude?: string[];
  /** Define mode selectors as media queries or CSS classes */
  modeSelectors?: ModeSelector[];
  /** Control the final CSS variable name */
  variableName?: (token: TokenNormalized) => string;
  /** Override certain token values */
  transform?: (token: TokenNormalized, mode: string) => TokenTransformed['value'];
  /** Generate utility CSS from groups */
  utility?: Record<UtilityCSSGroup, string[]>;
  /**
   * Output colors as hex-6/hex-8 instead of color() function
   * @default false
   */
  legacyHex?: boolean;
  /**
   * Skip generating any `.css` files (useful if you are consuming values in your own plugin and don’t need any `.css` files written to disk).
   * @default false
   */
  skipBuild?: boolean;
  /**
   * Set the base selector, like ":root" or ":host".
   * @default ":root"
   */
  baseSelector?: string;
}

export interface ModeSelector {
  /** The name of the mode to match */
  mode: string;
  /** Provide token IDs to match. Globs are allowed (e.g: `["color.*", "shadow.dark"]`) */
  tokens?: string[];
  /** Provide CSS selectors to generate. (e.g.: `["@media (prefers-color-scheme: dark)", "[data-color-theme='dark']"]` ) */
  selectors: string[];
}

// A CSSRule is a sort of “we have AST at home” shortcut that provides the benefit of normalized formatting
// but without the overhead/complexity of a full AST. It’s useful because we only generate a limited CSS
// syntax, and is a good balance between spec-compliance vs ease-of-use.
export interface CSSRuleDeclaration {
  value: string;
  description?: string;
}
export interface CSSRule {
  selectors: string[];
  nestedQuery?: string;
  declarations: Record<string, CSSRuleDeclaration>;
}

/** Convert CSSRules into a formatted, indented CSS string */
export function printRules(rules: CSSRule[]): string {
  const output: string[] = [];
  for (const rule of rules) {
    if (!rule.selectors.length || !Object.keys(rule.declarations).length) {
      continue;
    }

    const mqSelectors: string[] = [];
    const joinableSelectors: string[] = [];
    for (const s of rule.selectors) {
      (s.startsWith('@') ? mqSelectors : joinableSelectors).push(s);
    }
    // @media-query selectors get pushed individually
    for (const s of mqSelectors) {
      output.push(_printRule({ ...rule, selectors: [s] }));
    }
    // all other selectors get joined as one
    if (joinableSelectors.length) {
      output.push(_printRule({ ...rule, selectors: joinableSelectors }));
    }
  }

  return formatCSS(output.join('\n\n'));
}

/**
 * A factory function that creates a CSS declaration block manager.
 * Manages the nesting level of CSS declaration blocks.
 */
const createCSSDeclarationBlockManager = () => {
  let level = 0;

  return {
    /**
     * Increments the nesting level and returns the opening brace.
     * @returns The opening brace.
     */
    open() {
      level++;
      return '{';
    },
    /**
     * Decrements the nesting level and returns the closing brace.
     * @returns The closing brace.
     */
    close() {
      level--;
      return '}';
    },
    /**
     * Get the current nesting level.
     * @returns The nesting level.
     */
    getLevel() {
      return level;
    },
    /**
     * Reset the nesting level to 0 and returns the closing braces.
     * @returns The closing braces.
     */
    closeAll() {
      const closingBraces = '}'.repeat(level);
      level = 0;
      return closingBraces;
    },
  };
};

function _printRule(rule: CSSRule): string {
  const output: string[] = [];
  const isMediaQuery = rule.selectors.some((s) => s.startsWith('@'));
  const block = createCSSDeclarationBlockManager();

  // if both levels are media queries, preserve order
  if (rule.nestedQuery && isMediaQuery) {
    output.push(`${joinSelectors(rule.selectors)} ${block.open()}`);
    output.push(`${rule.nestedQuery} ${block.open()}`);
  }
  // otherwise if nested query exists but parens aren’t media queries, reverse order (media queries on top)
  else if (rule.nestedQuery && !isMediaQuery) {
    output.push(`${rule.nestedQuery} ${block.open()}`);
    output.push(`${joinSelectors(rule.selectors)} ${block.open()}`);
  }
  // if no media queries, just print selectors
  else {
    output.push(`${joinSelectors(rule.selectors)} ${block.open()}`);
  }

  // note: this is ONLY dependent on whether the top level is a media query (ignores nestedQuery)
  if (isMediaQuery) {
    output.push(`:root ${block.open()}`);
  }

  const declarations = Object.entries(rule.declarations);
  declarations.sort((a, b) => {
    const aIsVendorPrefixed = isVendorPrefixed(a[0]);
    const bIsVendorPrefixed = isVendorPrefixed(b[0]);

    // If one is vendor-prefixed and the other isn't, vendor-prefixed goes last
    if (aIsVendorPrefixed && !bIsVendorPrefixed) {
      return 1;
    }
    if (!aIsVendorPrefixed && bIsVendorPrefixed) {
      return -1;
    }

    // If both are vendor-prefixed or both are standard, sort alphabetically
    return a[0].localeCompare(b[0], 'en-us', { numeric: true });
  });
  for (const [k, d] of declarations) {
    output.push(`${k}: ${d.value};${d.description ? ` /* ${d.description} */` : ''}`);
  }

  output.push(block.closeAll());

  return output.join('');
}

export interface GetRuleOptions {
  /** Combine a selector with parent selectors (e.g. if adding a @media-query within another selector list) */
  parentSelectors?: string[];
}
