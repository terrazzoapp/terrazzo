import type { TokenNormalized, TokenTransformed } from '@terrazzo/parser';

export type UtilityCSSGroup = 'bg' | 'border' | 'font' | 'layout' | 'shadow' | 'text';

export type UtilityCSSPrefix = 'bg' | 'border' | 'font' | 'gap' | 'm' | 'p' | 'shadow' | 'text';

export const PLUGIN_NAME = '@terrazzo/plugin-css';

export const FORMAT_ID = 'css';

export const FILE_PREFIX = `/* -------------------------------------------
 *  Autogenerated by ⛋ Terrazzo. DO NOT EDIT!
 * ------------------------------------------- */`;

export interface CSSPluginOptions {
  /**
   * Where to output CSS
   * @default "index.css"
   */
  filename?: string;
  /** Glob patterns to filter tokens in output */
  include?: string[];
  /** Glob patterns to exclude tokens from output */
  exclude?: string[];
  /**
   * Set the base selector, like ":root" or ":host".
   * @deprecated use permutations instead.
   * @default ":root"
   */
  baseSelector?: string;
  /**
   * Set the color-scheme CSS property for `baseSelector`.
   * @deprecated use permutations instead.
   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Properties/color-scheme
   * @example "light dark"
   */
  baseScheme?: string;
  /**
   * Build resolver contexts into media queries
   */
  permutations?: Permutation[];
  /**
   * Define mode selectors as media queries or CSS classes
   * @deprecated Migrate to permutations
   */
  modeSelectors?: ModeSelector[];
  /** Control the final CSS variable name */
  variableName?: (token: TokenNormalized) => string;
  /** Override certain token values */
  transform?: (
    token: TokenNormalized,
    /** @deprecated */
    mode?: string,
  ) => TokenTransformed['value'] | undefined | null;
  /** Generate utility CSS from groups */
  utility?: Partial<Record<UtilityCSSGroup, string[]>>;
  /**
   * Output colors as hex-6/hex-8 instead of color() function
   * @default false
   */
  legacyHex?: boolean;
  /**
   * Skip generating any `.css` files (useful if you are consuming values in your own plugin and don’t need any `.css` files written to disk).
   * @default false
   */
  skipBuild?: boolean;
}

export interface Permutation<T extends Record<string, string> = Record<string, string>> {
  /** Generate the final CSS string, wrapping content in the selector(s) of your choice. */
  prepare(css: string): string;
  /** Input for this permutation. */
  input: T;
  /** Provide token(s) to include (Note: not including tokens that are used as aliases for other tokens could cause visual bugs in generated CSS) */
  include?: string[];
  /** Provide token(s) to exclude (Note: excluding tokens that are used as aliases for other tokens could cause visual bugs in generated CSS) */
  exclude?: string[];
}

export interface ModeSelector {
  /** The name of the mode to match */
  mode: string;
  /** Provide token IDs to match. Globs are allowed (e.g: `["color.*", "shadow.dark"]`) */
  tokens?: string[];
  /** Provide CSS selectors to generate. (e.g.: `["@media (prefers-color-scheme: dark)", "[data-color-theme='dark']"]` ) */
  selectors: string[];
  /** Set the color-scheme CSS property for this mode (e.g.: "light", "dark", "light dark") */
  scheme?: string;
}

// Simple AST types loosely-inspired by csstree.
export interface CSSDeclaration {
  type: 'Declaration';
  property: string;
  value: string;
  comment?: string;
}

export interface CSSRule {
  type: 'Rule';
  prelude: string[];
  children: (CSSRule | CSSDeclaration)[];
}

/**
 * Convert CSSRules into a formatted, indented CSS string.
 * The reason we’re using this homemade version instead of something like css-tree is:
 *
 * 1. css-tree doesn’t support comments :(
 * 2. we are only generating PARTIALS, not full CSS (the user controls the
 *    wrapper). So with a proper AST, we’d be hacking it a little anyway because
 *    we never really have a true, valid, finalized document.
 * 3. we want @terrazzo/plugin-css to run in the browser AND be lean (i.e. don’t
 *    load Prettier or 25MB of wasm).
 * 4. we only have to deal with a small subset of CSS—this doesn’t have to be robust
 *    by any means (even future additions won’t push the limits of the spec).
 */
export function printRules(
  nodes: (CSSRule | CSSDeclaration)[],
  { indentChar = '  ', indentLv = 0 }: { indentChar?: string; indentLv?: number } = {},
): string {
  let output = '';
  for (const node of nodes) {
    if (output && node.type === 'Rule') {
      output += '\n';
    }
    output += printNode(node, { indentChar, indentLv });
  }
  return output.trim();
}

/** Internal printer for individual nodes */
export function printNode(
  node: CSSRule | CSSDeclaration,
  { indentChar, indentLv }: { indentChar: string; indentLv: number },
): string {
  let output = '';

  const indent = indentChar.repeat(indentLv);

  if (node.type === 'Declaration') {
    if (node.comment) {
      output += `${indent}/* ${node.comment} */\n`;
    }
    output += `${indent}${node.property}: ${node.value};\n`;
    return output;
  }

  if (!node.prelude.length || !node.children.length) {
    return output;
  }

  // legacy behavior: mediaQueryWithDecls should be removed in 3.0. This
  // was originally introduced in modeSelectors, but it generates unexpected CSS.
  const mediaQueryWithDecls = node.children.some((s) => s.type === 'Declaration')
    ? node.prelude.find((s) => s.startsWith('@'))
    : undefined;
  if (mediaQueryWithDecls) {
    const nonMedia = node.prelude.filter((s) => s !== mediaQueryWithDecls);
    output += `${indent}${mediaQueryWithDecls} {\n`;
    output += printNode(rule([':root'], node.children), { indentChar, indentLv: indentLv + 1 });
    output += `${indent}}\n\n`;
    output += printNode(rule(nonMedia, node.children), { indentChar, indentLv });
    return output;
  }

  // Note: nested rules may eventually resolve to no declarations. This prevents that by rendering children first before the wrapper.
  let childOutput = '';
  for (const child of node.children) {
    childOutput += printNode(child, { indentChar, indentLv: indentLv + 1 });
  }
  childOutput = childOutput.trim();
  if (!childOutput) {
    return output;
  }
  output += `${indent}${node.prelude.join(', ')} {\n`;
  output += `${indentChar.repeat(indentLv + 1)}${childOutput}\n`;
  output += `${indent}}\n`;
  return output;
}

/** Infer indentation preferences from a user-defined wrapping method. */
export function getIndentFromPrepare(prepare: (css: string) => string): { indentChar: string; indentLv: number } {
  const str = '//css//'; // this is a string that’s invalid CSS that wouldn’t be in the fn itself
  const output = prepare(str).replace(/\/\*.*\*\//g, ''); // strip comments because we don’t need them
  let indentChar = '  ';
  let indentLv = 0;
  let lineStartChar = 0;
  for (let i = 0; i < output.length; i++) {
    if (output[i] === '{') {
      lineStartChar = i + 1;
      indentLv++;
    } else if (output[i] === '}') {
      indentLv--;
    } else if (output[i] === '\n') {
      lineStartChar = i + 1;
    } else if (output[i] === str[0] && output.slice(i).startsWith(str)) {
      indentChar = output.slice(lineStartChar, i);
      indentChar = indentChar.slice(0, Math.floor(indentChar.length / indentLv));
      break;
    }
  }
  return {
    indentChar: indentChar || '  ', // fall back to 2 spaces rather than no indentation
    indentLv,
  };
}

/** Syntactic sugar over Rule boilerplate */
export function rule(prelude: CSSRule['prelude'], children: CSSRule['children'] = []): CSSRule {
  return { type: 'Rule', prelude, children };
}

/** Syntactic sugar over Declaration boilerplate */
export function decl(
  property: CSSDeclaration['property'],
  value: CSSDeclaration['value'],
  comment?: CSSDeclaration['comment'],
): CSSDeclaration {
  return { type: 'Declaration', property, value, comment };
}

/** Does a node list contain a root-level declaration with this property? */
export function hasDecl(list: (CSSRule | CSSDeclaration)[], property: string): boolean {
  return list.some((d) => d.type === 'Declaration' && d.property === property);
}

/** Add a declaration only if it’s unique (note: CSS, by design, allows duplication—it’s how fallbacks happen. Only use this if fallbacks aren’t needed. */
export function addDeclUnique(list: (CSSRule | CSSDeclaration)[], declaration: CSSDeclaration): void {
  if (!hasDecl(list, declaration.property)) {
    list.push(declaration);
  }
}
