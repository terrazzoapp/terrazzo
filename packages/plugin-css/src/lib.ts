import type { TokenNormalized, TokenTransformed, TransformHookOptions } from '@terrazzo/parser';
import { validateCustomTransform } from '@terrazzo/token-tools';
import { generateShorthand, makeCSSVar, transformCSSValue } from '@terrazzo/token-tools/css';

export type UtilityCSSGroup = 'bg' | 'border' | 'font' | 'layout' | 'shadow' | 'text';

export type UtilityCSSPrefix = 'bg' | 'border' | 'font' | 'gap' | 'm' | 'p' | 'shadow' | 'text';

export const FORMAT_ID = 'css';

export const FILE_PREFIX = `/* -------------------------------------------
 *  Autogenerated by ⛋ Terrazzo. DO NOT EDIT!
 * ------------------------------------------- */`;

export interface CSSPluginOptions {
  /**
   * Where to output CSS
   * @default "index.css"
   */
  filename?: string;
  /** Glob patterns to exclude tokens from output */
  exclude?: string[];
  /**
   * Set the base selector, like ":root" or ":host".
   * @default ":root"
   */
  baseSelector?: string;
  /**
   * Set the color-scheme CSS property for `baseSelector`.
   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Properties/color-scheme
   * @example "light dark"
   */
  baseColorScheme?: string;
  /**
   * Set the resolver context(s) that should be applied for the root styles. If
   * using a resolver, this is required.
   */
  baseContext?: Record<string, string>;
  /**
   * Build resolver contexts into media queries
   */
  contextSelectors?: ContextSelector[];
  /**
   * Define mode selectors as media queries or CSS classes
   * @deprecated Migrate to contextSelectors
   */
  modeSelectors?: ModeSelector[];
  /** Control the final CSS variable name */
  variableName?: (token: TokenNormalized) => string;
  /** Override certain token values */
  transform?: (token: TokenNormalized, mode: string) => TokenTransformed['value'] | undefined | null;
  /** Generate utility CSS from groups */
  utility?: Partial<Record<UtilityCSSGroup, string[]>>;
  /**
   * Output colors as hex-6/hex-8 instead of color() function
   * @default false
   */
  legacyHex?: boolean;
  /**
   * Skip generating any `.css` files (useful if you are consuming values in your own plugin and don’t need any `.css` files written to disk).
   * @default false
   */
  skipBuild?: boolean;
}

export interface ContextSelector {
  /** Provide CSS selector to generate. */
  selector: string;
  /** Context to apply. Can be for just one modifier (`{ theme: "light" }`) or multiple ( `{ a: "one", b: "two", … }` ). */
  context: Record<string, string>;
  /** Provide token(s) to ignore (Note: ignoring tokens that are used as aliases for other tokens could cause visual bugs in generated CSS) */
  ignore?: string[];
  /**
   * Set the color-scheme CSS property for this mode.
   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Properties/color-scheme
   * @example "light dark"
   */
  colorScheme?: string;
}

export interface ModeSelector {
  /** The name of the mode to match */
  mode: string;
  /** Provide token IDs to match. Globs are allowed (e.g: `["color.*", "shadow.dark"]`) */
  tokens?: string[];
  /** Provide CSS selectors to generate. (e.g.: `["@media (prefers-color-scheme: dark)", "[data-color-theme='dark']"]` ) */
  selectors: string[];
  /** Set the color-scheme CSS property for this mode (e.g.: "light", "dark", "light dark") */
  scheme?: string;
}

// A CSSRule is a sort of “we have AST at home” shortcut that provides the benefit of normalized formatting
// but without the overhead/complexity of a full AST. It’s useful because we only generate a limited CSS
// syntax, and is a good balance between spec-compliance vs ease-of-use.
export interface CSSRuleDeclaration {
  value: string;
  description?: string;
}
export interface CSSRule {
  selectors: string[];
  nestedQuery?: string;
  declarations: Record<string, CSSRuleDeclaration>;
}

/** Convert CSSRules into a formatted, indented CSS string */
export function printRules(rules: CSSRule[]): string {
  const output: string[] = [];
  for (const rule of rules) {
    if (!rule.selectors.length || !Object.keys(rule.declarations).length) {
      continue;
    }

    const mqSelectors: string[] = [];
    const joinableSelectors: string[] = [];
    for (const s of rule.selectors) {
      (s.startsWith('@') ? mqSelectors : joinableSelectors).push(s);
    }
    // @media-query selectors get pushed individually
    for (const s of mqSelectors) {
      output.push(_printRule({ ...rule, selectors: [s] }));
    }
    // all other selectors get joined as one
    if (joinableSelectors.length) {
      output.push(_printRule({ ...rule, selectors: joinableSelectors }));
    }
  }
  return output.join('\n\n');
}

function _printRule(rule: CSSRule): string {
  const output: string[] = [];
  const isMediaQuery = rule.selectors.some((s) => s.startsWith('@'));
  let indent = '';

  // if both levels are media queries, preserve order
  if (rule.nestedQuery && isMediaQuery) {
    output.push(`${indent}${rule.selectors.join(`,\n${indent}`)} {`);
    indent += '  ';
    output.push(`${indent}${rule.nestedQuery} {`);
  }
  // otherwise if nested query exists but parens aren’t media queries, reverse order (media queries on top)
  else if (rule.nestedQuery && !isMediaQuery) {
    output.push(`${indent}${rule.nestedQuery} {`);
    indent += '  ';
    output.push(`${indent}${rule.selectors.join(`,\n${indent}`)} {`);
  }
  // if no media queries, just print selectors
  else {
    output.push(`${indent}${rule.selectors.join(`,\n${indent}`)} {`);
  }
  indent += '  ';

  // note: this is ONLY dependent on whether the top level is a media query (ignores nestedQuery)
  if (isMediaQuery) {
    output.push(`${indent}:root {`);
    indent += '  ';
  }

  for (const [k, d] of Object.entries(rule.declarations)) {
    output.push(`${indent}${k}: ${d.value};${d.description ? ` /* ${d.description} */` : ''}`);
  }

  // base closing brackets on indent level
  while (indent !== '') {
    indent = indent.substring(0, indent.length - 2);
    output.push(`${indent}}`);
  }

  return output.join('\n');
}

export interface GetRuleOptions {
  /** Combine a selector with parent selectors (e.g. if adding a @media-query within another selector list) */
  parentSelectors?: string[];
}

/**
 * Transform using legacy modeSelectors.
 * It’s not ideal for the old and new way to diverge this much, but this was
 * done to freeze the legacy behavior in place while allowing the new resolver
 * behavior to improve over time without regressions. The legacy behavior
 * transforms all contexts for all modes, which means it is guilty of doing work
 * even when not requested. In the new resolver world, world, work is only done
 * when needed, which means faster computations.
 */
export function legacyTransform(ctx: TransformHookOptions, options?: CSSPluginOptions) {
  function transformName(token: TokenNormalized) {
    const customName = options?.variableName?.(token);
    if (customName !== undefined) {
      if (typeof customName !== 'string') {
        throw new Error(`variableName() must return a string; received ${customName}`);
      }
      return customName;
    }
    return makeCSSVar(token.id);
  }
  const transformAlias = (token: TokenNormalized) => `var(${transformName(token)})`;

  for (const [id, token] of Object.entries(ctx.tokens)) {
    const localID = transformName(token);
    for (const mode of Object.keys(token.mode)) {
      if (options?.transform) {
        const value = options.transform(token, mode);
        if (value !== undefined && value !== null) {
          validateCustomTransform(value, { $type: token.$type });
          ctx.setTransform(id, {
            format: FORMAT_ID,
            localID,
            value,
            mode,
            meta: { 'token-listing': { name: localID } },
          });
          continue;
        }
      }

      const transformedValue = transformCSSValue(token, {
        mode,
        tokensSet: ctx.tokens,
        transformAlias,
        color: { legacyHex: options?.legacyHex },
      });
      if (transformedValue !== undefined) {
        let listingName: string | undefined = localID;

        // Composite tokens without a shorthand won't get generated in the output, so we don't list them.
        if (typeof transformedValue === 'object' && generateShorthand({ token, localID }) === undefined) {
          listingName = undefined;
        }

        ctx.setTransform(id, {
          format: FORMAT_ID,
          localID,
          value: transformedValue,
          mode,
          meta: { 'token-listing': { name: listingName } },
        });
      }
    }
  }
}
