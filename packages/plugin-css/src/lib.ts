import type { TokenNormalized, TokenTransformed } from '@terrazzo/parser';

export type UtilityCSSGroup = 'bg' | 'border' | 'font' | 'layout' | 'shadow' | 'text';

export type UtilityCSSPrefix = 'bg' | 'border' | 'font' | 'gap' | 'm' | 'p' | 'shadow' | 'text';

export const FORMAT_ID = 'css';

export const FILE_PREFIX = `/* -------------------------------------------
 *  Autogenerated by ⛋ Terrazzo. DO NOT EDIT!
 * ------------------------------------------- */`;

export interface CSSPluginOptions {
  /**
   * Where to output CSS
   * @default "index.css"
   */
  filename?: string;
  /** Glob patterns to exclude tokens from output */
  exclude?: string[];
  /**
   * Set the base selector, like ":root" or ":host".
   * @default ":root"
   */
  baseSelector?: string;
  /**
   * Set the color-scheme CSS property for `baseSelector`.
   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Properties/color-scheme
   * @example "light dark"
   */
  baseColorScheme?: string;
  /**
   * Set the resolver context(s) that should be applied for the root styles. If
   * using a resolver, this is required.
   */
  baseContext?: Record<string, string>;
  /**
   * Build resolver contexts into media queries
   */
  contextSelectors?: ContextSelector[];
  /**
   * Define mode selectors as media queries or CSS classes
   * @deprecated Migrate to contextSelectors
   */
  modeSelectors?: ModeSelector[];
  /** Control the final CSS variable name */
  variableName?: (token: TokenNormalized) => string;
  /** Override certain token values */
  transform?: (token: TokenNormalized, mode: string) => TokenTransformed['value'] | undefined | null;
  /** Generate utility CSS from groups */
  utility?: Partial<Record<UtilityCSSGroup, string[]>>;
  /**
   * Output colors as hex-6/hex-8 instead of color() function
   * @default false
   */
  legacyHex?: boolean;
  /**
   * Skip generating any `.css` files (useful if you are consuming values in your own plugin and don’t need any `.css` files written to disk).
   * @default false
   */
  skipBuild?: boolean;
}

export interface ContextSelector {
  /** Provide CSS selector to generate. */
  selector: string;
  /** Modifier to apply. Only one modifier can apply to a CSS selector. */
  modifier: string;
  /** Context to apply. Must be a valid context. */
  context: string;
  /** Provide token(s) to ignore (Note: ignoring tokens that are used as aliases for other tokens could cause visual bugs in generated CSS) */
  ignore?: string[];
  /**
   * Set the color-scheme CSS property for this mode.
   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Properties/color-scheme
   * @example "light dark"
   */
  colorScheme?: string;
}

export interface ModeSelector {
  /** The name of the mode to match */
  mode: string;
  /** Provide token IDs to match. Globs are allowed (e.g: `["color.*", "shadow.dark"]`) */
  tokens?: string[];
  /** Provide CSS selectors to generate. (e.g.: `["@media (prefers-color-scheme: dark)", "[data-color-theme='dark']"]` ) */
  selectors: string[];
  /** Set the color-scheme CSS property for this mode (e.g.: "light", "dark", "light dark") */
  scheme?: string;
}

// A CSSRule is a sort of “we have AST at home” shortcut that provides the benefit of normalized formatting
// but without the overhead/complexity of a full AST. It’s useful because we only generate a limited CSS
// syntax, and is a good balance between spec-compliance vs ease-of-use.
export interface CSSRuleDeclaration {
  value: string;
  description?: string;
}
export interface CSSRule {
  selectors: string[];
  nestedQuery?: string;
  declarations: Record<string, CSSRuleDeclaration>;
}

/** Convert CSSRules into a formatted, indented CSS string */
export function printRules(rules: CSSRule[]): string {
  const output: string[] = [];
  for (const rule of rules) {
    if (!rule.selectors.length || !Object.keys(rule.declarations).length) {
      continue;
    }

    const mqSelectors: string[] = [];
    const joinableSelectors: string[] = [];
    for (const s of rule.selectors) {
      (s.startsWith('@') ? mqSelectors : joinableSelectors).push(s);
    }
    // @media-query selectors get pushed individually
    for (const s of mqSelectors) {
      output.push(_printRule({ ...rule, selectors: [s] }));
    }
    // all other selectors get joined as one
    if (joinableSelectors.length) {
      output.push(_printRule({ ...rule, selectors: joinableSelectors }));
    }
  }
  return output.join('\n\n');
}

function _printRule(rule: CSSRule): string {
  const output: string[] = [];
  const isMediaQuery = rule.selectors.some((s) => s.startsWith('@'));
  let indent = '';

  // if both levels are media queries, preserve order
  if (rule.nestedQuery && isMediaQuery) {
    output.push(`${indent}${rule.selectors.join(`,\n${indent}`)} {`);
    indent += '  ';
    output.push(`${indent}${rule.nestedQuery} {`);
  }
  // otherwise if nested query exists but parens aren’t media queries, reverse order (media queries on top)
  else if (rule.nestedQuery && !isMediaQuery) {
    output.push(`${indent}${rule.nestedQuery} {`);
    indent += '  ';
    output.push(`${indent}${rule.selectors.join(`,\n${indent}`)} {`);
  }
  // if no media queries, just print selectors
  else {
    output.push(`${indent}${rule.selectors.join(`,\n${indent}`)} {`);
  }
  indent += '  ';

  // note: this is ONLY dependent on whether the top level is a media query (ignores nestedQuery)
  if (isMediaQuery) {
    output.push(`${indent}:root {`);
    indent += '  ';
  }

  for (const [k, d] of Object.entries(rule.declarations)) {
    output.push(`${indent}${k}: ${d.value};${d.description ? ` /* ${d.description} */` : ''}`);
  }

  // base closing brackets on indent level
  while (indent !== '') {
    indent = indent.substring(0, indent.length - 2);
    output.push(`${indent}}`);
  }

  return output.join('\n');
}

export interface GetRuleOptions {
  /** Combine a selector with parent selectors (e.g. if adding a @media-query within another selector list) */
  parentSelectors?: string[];
}
